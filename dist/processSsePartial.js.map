{"version":3,"file":"processSsePartial.js","sourceRoot":"","sources":["../src/processSsePartial.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,oBAAoB,CAAC;AAErD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAEtD,MAAM,CAAC,MAAM,iBAAiB,GAAG,KAAK,EAAK,EACzC,KAAK,EACL,UAAU,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,IAAS,EAChC,QAAQ,EACR,MAAM,EACN,IAAI,GAQL,EAAE,EAAE;IACH,MAAM,CAAC,YAAY,EAAE,OAAO,EAAE,UAAU,CAAC,GAAG,gBAAgB,CAAC,KAAK,EAAE;QAClE,MAAM;QACN,IAAI;KACL,CAAC,CAAC;IACH,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;YACrD,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;QACvD,CAAC;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,MAAM,OAAO,GAAG,cAAc,CAAC,YAAY,CAAC,CAAC;IAE7C,IAAI,OAAO,EAAE,CAAC;QACZ,KAAK,MAAM,OAAO,IAAI,OAAO,EAAE,CAAC;YAC9B,IAAI,SAAS,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,KAAK,MAAM,EAAE,CAAC;gBACnD,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;oBAClD,OAAO,EAAE,GAAG,OAAO,CAAC,KAAK,EAAE;iBAC5B,CAAM,CAAC;gBACR,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC;oBACrB,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;oBACjD,IAAI,YAAY,EAAE,CAAC;wBACjB,MAAM,CAAC,MAAM,EAAE,CAAC;oBAClB,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,+DAA+D;gBACjE,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,qDAAqD;gBACrD,mCAAmC;YACrC,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AAC9E,CAAC,CAAC","sourcesContent":["import { isDefined, safe } from \"@mjt-engine/object\";\nimport type { SseConsumer } from \"./SseConsumer\";\nimport { decodeSseValue } from \"./decodeSseValue\";\nimport { detectSimpleStop } from \"./detectSimpleStop\";\n\nexport const processSsePartial = async <T>({\n  input,\n  dataParser = (data) => data as T,\n  consumer,\n  reader,\n  done,\n}: {\n  done: boolean;\n  input: string;\n  reader: ReadableStreamDefaultReader<string>;\n\n  dataParser?: (data: string) => T | undefined;\n  consumer: SseConsumer<T>;\n}) => {\n  const [stopFragment, stopped, stopLength] = detectSimpleStop(input, [\n    \"\\n\\n\",\n    \"\\n\",\n  ]);\n  if (!stopped) {\n    if (!stopFragment) {\n      console.log(\"error\", [input, stopFragment, stopped]);\n      throw new Error(\"unexpected undefined stopFragment\");\n    }\n    return stopFragment;\n  }\n\n  const decodes = decodeSseValue(stopFragment);\n\n  if (decodes) {\n    for (const decoded of decodes) {\n      if (isDefined(decoded) && decoded.field === \"data\") {\n        const chunk = safe(() => dataParser(decoded.value), {\n          onError: `${decoded.value}`,\n        }) as T;\n        if (isDefined(chunk)) {\n          const consumerResp = await consumer(chunk, done);\n          if (consumerResp) {\n            reader.cancel();\n          }\n        } else {\n          // TODO better to allow consumer to know of failed chunk parse?\n        }\n      } else {\n        // TODO interface for other SSE fields if/when needed\n        // something we don't care about...\n      }\n    }\n  }\n\n  return stopFragment ? input.slice(stopFragment.length + stopLength) : input;\n};\n"]}