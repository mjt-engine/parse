{"version":3,"file":"createStreamParser.js","sourceRoot":"","sources":["../src/createStreamParser.ts"],"names":[],"mappings":"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","sourcesContent":["import { isDefined } from \"@mjt-engine/object\";\n\nexport type ComplexStopWord = {\n  pre: string; // start of word indicator\n  mid: string; // greedy match of word internals\n  post: string; // end of word indicator\n  name: string; // name of the stop word for classification\n};\n\n/**\n * remove any stopword references as well as any _potential_ stopword references\n */\nconst stopWordToCleanText = ({\n  text,\n  stopWord,\n}: {\n  text: string;\n  stopWord: ComplexStopWord;\n}): [string, boolean] => {\n  // the text could potentially have several partial matches.\n\n  const { pre, mid, post } = stopWord;\n\n  // if there is a post but does not match further, then give up\n  const postMatch = text.match(new RegExp(`${post}`));\n  if (postMatch) {\n    const preMidPostMatch = text.match(new RegExp(`${pre}${mid}${post}`));\n    if (preMidPostMatch && isDefined(preMidPostMatch.index)) {\n      return [text.slice(0, preMidPostMatch.index), true];\n    }\n    return [text, false];\n  }\n\n  // we are potentially in the middle of a match\n  // grab as much as we can to check later\n  const preMidMatch = text.match(new RegExp(`${pre}${mid}`));\n  if (preMidMatch && isDefined(preMidMatch.index)) {\n    return [text.slice(0, preMidMatch.index), false];\n  }\n\n  // since single char matching need to be able to check first chars directly\n  // possible that the mid regex might require stuff that just isn't possible yet\n  const preMatch = text.match(new RegExp(`${pre}`));\n  if (preMatch && isDefined(preMatch.index)) {\n    return [text.slice(0, preMatch.index), false];\n  }\n\n  return [text, false];\n};\n\nconst stopWordsToCleanText = ({\n  text,\n  stopWords,\n  onConsume = () => {},\n}: {\n  text: string;\n  stopWords: ComplexStopWord[];\n  onConsume?: (text: string, stopWord: ComplexStopWord) => void;\n}): [string, boolean] => {\n  let cleanResult = text;\n\n  for (const stopWord of stopWords) {\n    const [cleaned, consumed] = stopWordToCleanText({\n      text: cleanResult,\n      stopWord: stopWord,\n    });\n    if (consumed) {\n      onConsume(text, stopWord);\n      return [cleaned, consumed];\n    }\n    cleanResult = cleaned;\n  }\n\n  return [cleanResult, false];\n};\n\nexport const createStreamParser = ({\n  onConsume,\n  stopWords = [],\n}: {\n  stopWords: ComplexStopWord[];\n  onConsume?: (text: string, stopWord: ComplexStopWord) => void;\n}) => {\n  let buffer: string = \"\";\n\n  const transformStream = new TransformStream<string, string>({\n    transform: (chunk, controller) => {\n      if (!chunk || chunk.length === 0) {\n        return;\n      }\n      buffer = `${buffer}${chunk}`;\n\n      const [cleaned, consumed] = stopWordsToCleanText({\n        text: buffer,\n        stopWords,\n        onConsume,\n      });\n      buffer = consumed ? \"\" : buffer.slice(cleaned.length);\n      if (cleaned.length > 0) {\n        controller.enqueue(cleaned);\n      }\n    },\n    start: (controller) => {},\n    flush: (controller) => {\n      controller.terminate();\n    },\n  });\n\n  const reader = transformStream.readable.getReader();\n  const writer = transformStream.writable.getWriter();\n\n  return {\n    reader,\n    write: (text: string) => {\n      text.split(\"\").forEach((c) => writer.write(c));\n    },\n    close: () => {\n      writer.close();\n    },\n  };\n};\n"]}